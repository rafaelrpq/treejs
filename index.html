<!DOCTYPE html>
<html lang="en">
<head>

    <style>
  body {
    margin: 0;
  }
</style>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
        

        const Input = {
            keys: {
                UP: false,
                DOWN: false,
                LEFT: false,
                RIGHT: false,
                SPACE: false,
            },
            mouse: {
                x: 0,
                y: 0,
                down: false
            },
            
            listener: (e) => {
                const state = e.type === 'keydown' ? true : false
                switch (e.key) {
                    case 'ArrowUp':
                        Input.keys.UP = true
                        break
                    case 'ArrowDown':
                        Input.keys.DOWN = true
                        break
                    case 'ArrowLeft':
                        Input.keys.LEFT = true
                        break
                    case 'ArrowRight':
                        Input.keys.RIGHT = true
                        break
                    case ' ':
                        Input.keys.SPACE = true
                        break
                }
            },

            handler: (cube) =>{
                if (Input.keys.UP) {
                    cube.position.z += 0.1
                } else if (Input.keys.DOWN) {
                    cube.position.z -= 0.1
                } else {
                    cube.position.z = 0 // Reset Z position if no input
                }
                
                if (Input.keys.LEFT) {
                    cube.position.x -= 0.1
                } else if (Input.keys.RIGHT) {
                    cube.position.x += 0.1
                } else {
                    cube.position.x = 0 // Reset X position if no input
                }

                if (Input.keys.SPACE) {
                    cube.position.y += 0.5 // Simulate jump 
                } else {
                    // cube.position.y = 0 // Reset Y position if no input
                } 
            }
               
        }


        window.addEventListener('keydown', Input.listener)
        window.addEventListener('keyup', Input.listener)
        
        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        )
        camera.position.set (8,2,16)
        
        const renderer = new THREE.WebGLRenderer()
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMap.enabled = true
        
        document.body.appendChild(renderer.domElement)
        
        const light = new THREE.DirectionalLight(0xffffff, 1)
        light.position.y = 3
        light.position.z = 2
        
        light.castShadow = true
        scene.add(light)
        

        const controls = new OrbitControls(camera, renderer.domElement)
        
        class Box extends THREE.Mesh {
            constructor({
                width, height, depth, color, 
                velocity = {x: 0, y: 0, z: 0},
                position = {x: 0, y: 0, z: 0}
            }) {
                super (
                    new THREE.BoxGeometry(width, height, depth), 
                    new THREE.MeshStandardMaterial({ color })
                )
                this.height = height
                this.width  = width
                this.depth  = depth
                
                this.position.set(position.x, position.y, position.z)

                this.bottom = this.position.y - this.height / 2
                this.top    = this.position.y + this.height / 2

                this.velocity = velocity
                this.gravity = -0.005

            }

            update(group) {
                this.bottom = this.position.y - this.height / 2
                this.top    = this.position.y + this.height / 2
                this.applyGravity()
            }

            applyGravity() {
                this.velocity.y += this.gravity
                
                if (this.bottom + this.velocity.y <= ground.top) {
                    this.velocity.y *= 0.8
                    this.velocity.y *= -1
                } else {
                    this.position.y += this.velocity.y 
                }
            }
        }
        
    

        const cube = new Box({
            width  : 1, 
            height : 1, 
            depth  : 1,
            color  : 0x00ff00,
            velocity: {x: 0, y: -0.01, z: 0},
            position: {x: 0, y: 0, z: 0}
        })
        cube.castShadow = true
        scene.add(cube)
        
        
        const ground = new Box({
            width  : 5, 
            height : 0.25, 
            depth  : 10,
            color  : 0x808080,
            position: {x: 0, y: -2, z: 0}
        })
        
        
        ground.receiveShadow = true
        scene.add(ground)
    
    
        function animate() {
            requestAnimationFrame(animate)
            renderer.render(scene, camera)
            // cube.rotation.x += 0.01
            // cube.rotation.y += 0.01
            Input.handler(cube)
            
            cube.update(ground)    
        }
        
        animate()
    </script>
</head>
<body>
</body>
</html>